# 1. Routes

![Graphic for Web Applications](https://paper-attachments.dropbox.com/s_3974FDD251938B6FB06DC9763D381A8D4F29C452AEC3A8BFE8E01688B0AA90C7_1567475490610_web-app-structure.png)

## Clients

Clients are the computers we use everyday, including phones, tablets, laptops, desktops, and gaming consoles. Clients run code locally on their machine. Things like rendering images, reacting to button clicks and user input are all done as part of the frontend of an application. What makes an application truly “networked”, i.e. involving actions from other clients, is the backend of the application. These backends exist in the cloud, running on servers.

## Servers

Servers are also computers, just like clients. Servers centralize information and run backend code to execute operations to data and communicate with clients. This is the **Server-Client Model** and it is how the internet is architected today. Independent machines \(like a phone, computer, etc.\) make requests to servers and use the data returned in responses.

## Requests

Requests are the network calls transferred over the web. Let’s dissect a request made to `http://www.google.com`:

  
`http`: Hyper Text Transfer Protocol defines the protocol for the request and is reserved for port 80 on servers.  HTTP requests can be made with one of many types of **methods**. A method indicates the type of request being sent and how to handle the request. The most common methods used are GET, POST, DELETE, PUT, PATCH and are all standardized by HTTP protocol. Methods indicate the purpose of the request. GET is for information retrieval, POST for information transmission, DELETE for deleting, PUT & PATCH both for updating. Requests can also contain metadata, optional information located in the **body** of the request. Metadata can be in many forms, the two most common are XML and JSON. A request **body** is likely populating in the case of creating or updating items in the database.  


`www`: The subdomain we are trying to access.

  
`google`: The domain we are trying to access. A Domain Name Service \(DNS\) will map this domain to a specific server for you to communicate with.  

  
Going to `http://www.google.com` makes a GET request to the google domain. Similarly we can send a POST request to `http://www.google.com/login` to login our user. In the case of logging in, our POST request’s body will likely contain email/password information to be authenticated on the server.  


## Responses

Servers respond the exact same way with their own network calls. They also obey HTTP protocol and have the ability to contain metadata in a response body. Responses also contain specific codes giving us a high-level understanding of how the request was handled. Some common examples are:

* 200 → Successful
* 404 → Not found
* 500 → Internal server error \(an uncaught exception\)

## The Whole Process

1. A client makes a request for specific pieces of data that are sent out over the internet
2. The request is received by a server
3. The server runs internal processes to create, retrieve, update, or delete items
4. The server returns response back to client over the internet

## Demo

### Introduction to Flask

Our chosen framework for this course is Flask. We can create a simple application with:

```python
from flask import Flask, request
app = Flask(__name__)app.run()
```

We can define the handling of requests with **routes**. We can define a route like any normal method by adding the `@app.route` decorator:

```python
@app.route('/', methods=['GET'])
def hello():
  return "Hello World!"
```

Let us test our app by adding code to allow our application to be a callable executable from the command line:

```python
if __name__ == '__main__':
  app.run(host='0.0.0.0', port=5000, debug=True)
```

This tells Python that if this file is run as a script, then run the Flask application with the settings indicated in the arguments to `app.run()`:

* `host='0.0.0.0'` tells the application to run on our local computer \(localhost\)
* `port=5000` indicates the port to run the application on
* `debug=True` allows Flask to give us handy debug messages while the app is running

Now if we go back to our command line and run `python app.py` we should see a message from Flask like:

```bash
>>> python app.py 
* Serving Flask app "app" (lazy loading)
* Environment: production
  WARNING: Do not use the development server in a production environment.
  Use a production WSGI server instead.
* Debug mode: on
* Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
* Restarting with stat
* Debugger is active!
* Debugger PIN: 237-805-669
```

We can see confirmation in this message that our debugger is on and that our application is running on our computer on port 5000 \(`Running on http://0.0.0.0:5000/`\). Now if we visit the URL `localhost:5000`, we will see `Hello World!` as plain HTML on our screen.

If we turn back to our terminal, we can also see our two requests printed:

```bash
127.0.0.1 - - [03/Sep/2019 21:04:17] "GET / HTTP/1.1" 200 -
127.0.0.1 - - [03/Sep/2019 21:04:21] "GET /tasks/ HTTP/1.1" 200 -
```

### Task App

Consider we want to make an application to keep a task list. Let us start by creating our flask app and some data we want to store with a simple dictionary on a new file, `app.py`:

```python
import json
from flask import Flask, request

app = Flask(__name__)

tasks = {
  0: {
    'id': 0,
    'description': 'laundry',
    'done': False
  },
  1: {
    'id': 1,
    'description': 'homework',
    'done': False
  }
}

```

We will now create our first route to get all of our tasks.

```python
@app.route('/tasks/')
def get_all_tasks():
  res = {'success': True, 'data': list(tasks.values())}
  return json.dumps(res), 200
```

#### Function Definition

The argument `/tasks/` indicates that this route will be triggered upon receiving a request with `/tasks/`. There is also an optional argument methods that specifies the acceptable request methods and the default is to only allow GET requests. We must define a method below our `@app.route()` decorator to call upon hitting the route; for this route we can define the method `get_all_tasks()` to get all of our task objects.

#### Execution

Our first step is to gather all of our data into a payload to return. It is common practice to return a response that includes additional information about the request along with our data. For our purposes, we will just include a `success` field that indicates if the request was successful or not in execution. However, we cannot return python dictionaries over the internet, we must convert this into a JSON representation. We do this by using the `json` library, specifically `json.dumps(dict)` to dump our dictionary into a JSON object. When we return this data, we can also provide a HTTP response code too for good measure \(we will use 200 to indicate a successful response\).

### Posting

Now we will allow for the creation of new tasks with a POST route.  We first need to consider how we will increment our ids. A simple solution is to keep a variable that increments after each task creation to ensure uniqueness of ids.  We will add a new variable `task_id_counter` where we defined our initial tasks for now.

```python
@app.route('/tasks/', methods=['POST'])
def create_task():
  global task_id_counter
  post_body = json.loads(request.data)
  description = post_body['description']
  task = {
    'id': task_id_counter,
    'description': description,
    'done': False
  }
  tasks[task_id_counter] = task
  task_id_counter += 1
  return json.dumps({'success': True, 'data': task}), 201
```

####  Function Definition

For creating new tasks, we can use the same path as in the previous request, but change the allowable request methods to create a uniquely identifiable route. Because we are expecting a data payload as part of a request, we should allow the POST request method to allow for such request bodies.  

####  **Execution**

Our first step is to access the body of the POST request using Flask’s provided `request.data`.  We load this into a Python dictionary to utilize the contents so we must pass this JSON into `json.loads()` to convert it. We will create our new task object by constructing a new dictionary object and insert the description value provided by the request’s body. We will default done to False \(because how can we complete a task that was just created\) and we set our id using a global counter to keep track of what the next id should be. We can add this task to our `tasks` global dictionary data story like adding to any dictionary and we finish by incrementing our global `task_id_counter` to make sure that the next id is also unique.  

### Getting singular

Now let’s add functionality for the case where we would like to get a singular task.

```python
@app.route('/tasks/<int:task_id>/') 
def get_task(task_id):
  task = tasks.get(task_id, None)
  if not task:
    return json.dumps({'success': False, 'error': 'Task not found'}), 404
  return json.dumps({'success': True, 'data': task}), 200
```

#### **Function Definition**

Now consider that we want to only retrieve a singular task from our application. We need to create a new route for our users that know the id of the specific task they want. To indicate this task id, we imbed a variable within the route’s path, noted by `<int:task_id>`.  This tells Flask to expect an integer \(which we name `task_id`\) and allows us to take in this argument with our function matched with this route, `get_task`.

#### **Execution**

Now that we have a specific task id requested, we can search in our dictionary data store to grab our particular task \(remember that the keys in this dictionary are unique ids\).  We can use python’s build in `get()` function for dictionary objects, and provide a default value of None if there does not exist an item in our tasks with id `task_id`.  Depending on if we have retrieved a task object or not, we can return either a successful or failed response.

### Updating

Now let’s add functionality for the case where we would like to update a task.

```python
@app.route('/tasks/<int:task_id>/', methods=['POST']) 
def update_task(task_id):
  task = tasks.get(task_id, None)
  if not task:
    return json.dumps({'success': False, 'error': 'Task not found'}), 404
  post_body = json.loads(request.data)
  task['description'] = post_body['description']
  task['done'] = post_body['done']
  return json.dumps({'success': True, 'data': task}), 200
```

#### **Function Definition**

To update a particular task, we can use the same path defined in retrieving a specific task, but simply change the allowed request methods to accept only POST requests.  Because incoming request use the POST method, they will contain a body containing the data we wish to update our task with.

#### Execution

Just like in the previous route, we can attempt to retrieve the task from our `tasks` object and return a failed response if we cannot find it. If we do retrieve a task, we can begin the updating process. To start, we need to parse our incoming request’s data. We can use the same loading mechanism for `request.data` as we did when creating tasks and set our task’s fields with these new ones. Upon updating our task object, we can return a successful response.

### Deleting

Now let’s add functionality for the case where we would like to delete a task.

```python
@app.route('/tasks/<int:task_id>/', methods=['DELETE']) 
def delete_task(task_id):
  task = tasks.get(task_id, None)
  if not task:
    return json.dumps({'success': False, 'error': 'Task not found'}), 404
  del tasks[task_id]
  return json.dumps({'success': True, 'data': task}), 200
```

#### Function Definition

To delete a particular task, we can use the same path defined in retrieving a specific task, but simply change the allowed request methods to accept only DELETE requests.

#### **Execution**

If we cannot find our task, we return a failed response. Otherwise, we remove the task from our tasks object and return a successful response.

